// 4월 4일 내용
// Array(배열)
// size_type      :64x -> 8byte, 86x -> 4byte.

// array는 C++11에서 추가된 고정 크기 배열 타입으로,
// C 스타일의 배열보다 안전하고 유연한 사용을 제공합니다.
// C 스타일 배열과 달리 크기가 컴파일 타임에 결정되며,
// 런타임에 크기가 변경될 수 없습니다.

// std::array<T, N> 형태로 정의됩니다.
// 여기서 T는 배열에 저장할 요소의 타입이고, 
// N은 배열의 크기입니다.

// 예를 들어, std::array<int, 5>는 크기가 5이며 int형 요소를 저장하는 배열을 나타냅니다.

//  C 스타일 배열과 같이 인덱스로 요소에 접근할 수 있으며,
// at() 함수를 사용하여 범위를 벗어나는 접근을 방지할 수 있습니다.
// 또한, STL 알고리즘과 함께 사용할 수 있으며, 범위 기반 for 루프를 사용하여 배열의 요소를 순회할 수 있습니다.

// STL array의 크기는 컴파일 타임에 결정되기 때문에,
// 동적 할당을 사용하는 C 스타일 배열보다 안전합니다.
// 또한, STL array는 스택 메모리에 저장되므로, 
// 동적 할당을 사용하는 C 스타일 배열보다 더 빠릅니다.

// 하지만, 배열의 크기가 고정되어 있기 때문에, 크기를 변경할 수 없다는 제약이 있습니다.

// decay란, 
// C++에서 배열, 함수 또는 포인터와 같은 복잡한 타입을 단순화하거나 기본 형식으로 변환하는 프로세스를 말합니다.

// 예를 들어, decay는 배열 타입을 해당 요소 타입으로 변환하고,
// 함수 타입을 해당 반환 타입을 갖는 포인터 타입으로 변환합니다.
// decay는 템플릿 타입 매개변수를 처리하는 데 유용하게 사용됩니다.
// 이를 통해 템플릿 함수 또는 클래스가 다양한 타입의 인수를 받을 수 있으며, 이러한 인수가 일관된 방식으로 처리될 수 있습니다.

#include <iostream>
#include <typeinfo>

void foo(int arr[]) {
    std::cout << typeid(arr).name() << std::endl;
}

int main() {
    int arr[5] = { 1, 2, 3, 4, 5 };
    std::cout << typeid(arr).name() << std::endl;
    foo(arr);
    return 0;
}

// 위 코드는 함수 foo가 int형 배열을 받아 출력하는 간단한 예시입니다.
// main 함수에서 arr을 출력하면 int[5] 라는 결과를 출력합니다.
// 이는 arr이 int 자료형으로 이루어진 길이 5의 배열이라는 것을 의미합니다.
// 반면에, foo 함수의 매개변수 arr을 출력하면 int* 라는 결과를 출력합니다.
// 이는 배열 arr이 포인터로 변환되어 전달된다는 것을 의미합니다.

// 즉, arr이라는 배열이 함수의 인자로 전달될 때
// 배열 형태가 사라지고 포인터 형태로 전달되는데, 이러한 변환 과정을 decay 라고 합니다.